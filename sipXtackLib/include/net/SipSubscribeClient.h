// 
// Copyright (C) 2007 Pingtel Corp., certain elements licensed under a Contributor Agreement.  
// Contributors retain copyright to elements licensed under a Contributor Agreement.
// Licensed to the User under the LGPL license.
// 
// $$

//////////////////////////////////////////////////////////////////////////////
#ifndef _SipSubscribeClient_h_
#define _SipSubscribeClient_h_

// SYSTEM INCLUDES

// APPLICATION INCLUDES

#include <os/OsDefs.h>
#include <os/OsServerTask.h>
#include <utl/UtlHashMap.h>
#include <net/SipRefreshManager.h>

// DEFINES
// MACROS
// EXTERNAL FUNCTIONS
// EXTERNAL VARIABLES
// CONSTANTS
// STRUCTS
// FORWARD DECLARATIONS
class SipMessage;
class SipUserAgent;
class SipDialogMgr;
class SipRefreshManager;
class SubscribeClientState;

// TYPEDEFS

//! Class for maintaining the subscriber role of SIP subscriptions
/** Once a SipSubscribeClient has been created, it can be directed to
 *  create and maintain subscriptions.  SUBSCRIBE messages are sent
 *  using addSubscription.  Each use of addSubscription creates an
 *  early dialog, and any subscriptions that are established are
 *  created as established dialogs.  The creation and destruction of
 *  early and established dialogs is reported through a callback
 *  function, and the contents of any NOTIFYs received in the
 *  subscriptions is reported through another callback function.
 *
 *  Note that if an established subscription is ended due to error or
 *  action of the notifier, SipSubscribeClient does not attempt to
 *  re-create it.
 */
class SipSubscribeClient : public OsServerTask
{
/* //////////////////////////// PUBLIC //////////////////////////////////// */
public:

    enum SubscriptionState
    {
        SUBSCRIPTION_UNKNOWN,
        SUBSCRIPTION_INITIATED, // Early dialog
        SUBSCRIPTION_SETUP,     // Established dialog
        SUBSCRIPTION_FAILED,    // Failed dialog setup or refresh
        SUBSCRIPTION_TERMINATED // Ended dialog
    };

    /// Type of the callback function for reporting subscription state changes.
    /** Note SipSubscribeClient does automatically refresh subscriptions, but
     *  if the subscription is involuntarily ended (by the notifier or otherwise),
     *  SipSubscribeClient will not attempt to reestablish it.
     */
    typedef void (*SubscriptionStateCallback)
       (SipSubscribeClient::SubscriptionState newState,
        const char* earlyDialogHandle,
        const char* dialogHandle,
        void* applicationData,
        int responseCode,
        const char* responseText,
        long expiration,
        const SipMessage* subscribeResponse);

    /// Type of the callback function for reporting received NOTIFYs.
    /** Note that NOTIFYs are generally reported in the order they are
     *  received.  Duplicated NOTIFYs are not reported, as the duplicated
     *  messages are removed in the SIP stack.  Similarly, out-of-order
     *  NOTIFYs are rejected in the SIP stack and are not reported.
     *  This provides the desired behavior if the notifications for a
     *  subscription give a complete update of the subscription's
     *  state.  If notifications only give partial updates, and so
     *  missed NOTIFYs must be detected, the NOTIFYs need to contain
     *  serial numbers (as many SIP event packages do), as the CSeq
     *  numbers cannot be relied upon to be sequential.
     *  (If the application needs a full update, it must direct
     *  SipSubscribeClient to terminate the subscription and begin a
     *  new one.)
     */
    typedef void (*NotifyEventCallback)
       (const char* earlyDialogHandle,
        /**< handle of the early dialog generated
         *   by the SUBSCRIBE.
         */
        const char* dialogHandle,
        /**< handle of the established
         *   dialog generated by the first NOTIFY.
         */
        void* applicationData,
        const SipMessage* notifyRequest);

/* ============================ CREATORS ================================== */

    //! Default Dialog constructor
    SipSubscribeClient(SipUserAgent& userAgent, 
                       SipDialogMgr& dialogMgr,
                       SipRefreshManager& refreshMgr);

    //! Destructor
    virtual
    ~SipSubscribeClient();

/* ============================ MANIPULATORS ============================== */

    //! Create a SIP event subscription based on values specified to create a SUBSCRIBE message
    /*! 
     *  Returns TRUE if the SUBSCRIBE request was sent and the 
     *  Subscription state proceeded to SUBSCRIPTION_INITIATED.
     *  Returns FALSE if the SUBSCRIBE request was not able to
     *  be sent, the subscription state is set to SUSCRIPTION_FAILED.
     */
    UtlBoolean addSubscription(const char* resourceId,
                               const char* eventHeaderValue,
                               const char* acceptHeaderValue,
                               const char* fromFieldValue,
                               const char* toFieldValue,
                               const char* contactFieldValue,
                               int subscriptionPeriodSeconds,
                               void* applicationData,
                               const SubscriptionStateCallback subscriptionStateCallback,
                               const NotifyEventCallback notifyEventsCallback,
                               UtlString& earlyDialogHandle);

    //! Create a SIP event subscription based on a provided SUBSCRIBE request
    /*! 
     *  Returns TRUE if the SUBSCRIBE request was sent and the 
     *  Subscription state proceeded to SUBSCRIPTION_INITIATED.
     *  Returns FALSE if the SUBSCRIBE request was not able to
     *  be sent, the subscription state is set to SUSCRIPTION_FAILED.
     */
    UtlBoolean addSubscription(SipMessage& subscriptionRequest,
                               void* applicationData,
                               const SubscriptionStateCallback subscriptionStateCallback,
                               const NotifyEventCallback notifyEventsCallback,
                               UtlString& earlyDialogHandle);

    //! End the SIP event subscription indicated by the dialog handle
    /*! If the given dialogHandle is an early dialog it will end any
     *  established or early dialog subscriptions.  Typically the
     *  application SHOULD use the established dialog handle.  This
     *  method can also be used to end one of the dialogs if multiple
     *  subsription dialogs were created as a result of a single 
     *  subscribe request.  The application will get multiple 
     *  SUBSCRIPTION_SETUP SubscriptionStateCallback events when
     *  multiple dialogs are created as a result of a single SUBSCRIBE.
     *  To end one of the subscriptions the application should use
     *  the setup dialogHandle provided by the SubscriptionStateCallback.
     */
    UtlBoolean endSubscription(const char* dialogHandle);

    //! End all subscriptions
    void endAllSubscriptions();

    //! Handler for NOTIFY requests
    UtlBoolean handleMessage(OsMsg &eventMessage);

/* ============================ ACCESSORS ================================= */

    //! Create a debug dump of all the client states
    int dumpStates(UtlString& dumpString);

    //! Get a string representation of the client state enumeration
    static void getSubscriptionStateEnumString(enum SubscriptionState stateValue, 
                                               UtlString& stateString);

/* ============================ INQUIRY =================================== */

    //! Get a count of the subscriptions which have been added
    int countSubscriptions();

/* //////////////////////////// PROTECTED ///////////////////////////////// */
protected:

/* //////////////////////////// PRIVATE /////////////////////////////////// */
private:
    //! Callback to handle subscription state changes from the refresh manager
    /*! RefreshStateCallback
     */
    static void refreshCallback(SipRefreshManager::RefreshRequestState newState,
                               const char* earlyDialogHandle,
                               const char* dialogHandle,
                               void* subscribeClientPtr,
                               int responseCode,
                               const char* responseText,
                               long expiration, // epoch seconds
                               const SipMessage* subscribeResponse);

    //! Handle incoming notify request
    void handleNotifyRequest(const SipMessage& notifyRequest);

    //! Add the client state to the container
    void addState(SubscribeClientState& clientState);

    //! find the state from the container that matches the dialog
    /* Assumes external locking
     */
    SubscribeClientState* getState(const UtlString& dialogHandle);

    //! remove the state from the container that matches the dialog
    /* Assumes external locking
     */
    SubscribeClientState* removeState(UtlString& dialogHandle);

    //! lock for single thread use
    void lock();
    //! lock for single thread use
    void unlock();

    //! Copy constructor NOT ALLOWED
    SipSubscribeClient(const SipSubscribeClient& rSipSubscribeClient);

    //! Assignment operator NOT ALLOWED
    SipSubscribeClient& operator=(const SipSubscribeClient& rhs);

    SipUserAgent* mpUserAgent;
    SipDialogMgr* mpDialogMgr;
    SipRefreshManager* mpRefreshMgr;
    UtlHashMap mSubscriptions; // state info. for each subscription
    UtlHashMap mEventTypes; // SIP event types that we want NOTIFY requests for
    OsMutex mSubcribeClientMutex;
    int mCallIdCount;
    int mTagCount;
};

/* ============================ INLINE METHODS ============================ */

#endif  // _SipSubscribeClient_h_
