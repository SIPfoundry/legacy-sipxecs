# Copyright (c) 2012 eZuce, Inc. All rights reserved.
# Contributed to SIPfoundry under a Contributor Agreement

# This software is free software; you can redistribute it and/or modify it under
# the terms of the Affero General Public License (AGPL) as published by the
# Free Software Foundation; either version 3 of the License, or (at your option)
# any later version.

# This software is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more
# details.

#
# Postgres configuration for working with sipxecs
#

bundle agent sipxdns {
  vars:
    "managed_ext" 
      string => "",
      policy => "overridable";
    sipxdns_unmanaged::
      "managed_ext" string => ".unmanaged";

  methods:
    sipxdns::
      "any" usebundle => sipxdns_config;

    resolv::
      "any" usebundle => sipxdns_resolv;

    !src.!sipxdns_unmanaged::
      "any" usebundle => sipxdns_setup;

    !sipxdns_unmanaged::
      "any" usebundle => sipxdns_running;
}

bundle agent sipxdns_resolv {
  files:
    any::
      "/etc/resolv.conf$(sipxdns.managed_ext)"
        comment => "add nameservers to $(this.promiser)",
        create => "true",
        perms => m(644),
        edit_line => resolv_conf,
        edit_defaults => std_defs;
}

bundle agent sipxdns_config {
  files:
    any::
      "$(sipx.SIPX_CFDATA)/$(sipx.location_id)/zone.yaml$(sipxdns.managed_ext)"
        comment => "check for updates in DNS zone info file $(this.promiser)",
        changes => repair_on_change,
        classes => if_repaired("update_zone"),
        action => fix;

      "/etc/named.conf$(sipxdns.managed_ext)"
        comment => "install DNS config file $(this.promiser)",
        create => "true",
        perms => mog(600, "named", "root"),
        edit_line => named_conf,
        edit_defaults => empty,
        classes => if_repaired("reload_sipxdns");
        
    update_zone::
      "/var/named/$(sipx.domain).zone$(sipxdns.managed_ext)"
        comment => "install DNS zone file $(this.promiser)",
        create => "true",
        perms => mog(600, "named", "named"),
        transformer => "$(sipx.SIPX_LIBEXECDIR)/sipx-dns-zone-maker --in $(sipx.SIPX_CFDATA)/$(sipx.location_id)/zone.yaml --out /var/named/$(sipx.domain).zone$(sipxdns.managed_ext)",
        classes => if_repaired("reload_sipxdns");
}

bundle edit_line named_conf {
  insert_lines:
    "
options {
    directory  \"/var/named\";
    dump-file \"/var/named/data/cache_dump.db\";
    statistics-file \"/var/named/data/named_stats.txt\";
    allow-query { any; };
    forwarders {
      $(sipx.sipxdns_forwarders)
    };
};

zone \"$(sipx.domain)\"  IN  {
     type master;
     file \"$(sipx.domain).zone\";
     allow-update { none; };
};
";
}

bundle edit_line resolv_conf {
  insert_lines:
    "# Generated by sipXecs ";
    "$(sipx.SIPX_CFDATA)/$(sipx.location_id)/resolv.conf.part"
      insert_type => "file";

  delete_lines:
    ".*";
}

bundle agent sipxdns_setup {
  methods:
    sipxdns::
      "any" usebundle => rh_chkconfig_status("named on");
    !sipxdns::
      "any" usebundle => rh_chkconfig_status("named off");
}

bundle agent sipxdns_running {
  vars:
    any::
      "service" string => "/etc/init.d/named";
      "service_command" string => "/usr/sbin/named";

  methods:
    any::
      "any" usebundle => find_service_by_command("$(service_command)", "sipxdns_running", "named");

  commands:
    # NOTE : Not shutting off  explicit stop function because we cannot tell if
    # admin is configuring and managing DNS on their own (which is the 
    # case for a lot of ezuce developers anyway)
    (!sipxdns|stop_sipxecs).!src.sipxdns_running::
      "$(service)"
        comment => "stop named",
        args => "stop";

    sipxdns.!sipxdns_running.!stop_sipxecs::
      "$(service)"
        comment => "start named",
        args => "start";

    sipxdns.sipxdns_running.(restart_sipxdns|restart_sipxecs)::
      "$(service)"
        comment => "restart named",
        args => "restart";

    sipxdns.sipxdns_running.reload_sipxdns::
      "$(service)"
        comment => "reload named",
        args => "reload";
}