# Copyright (C) 2011 eZuce Inc., certain elements licensed under a Contributor Agreement.
# Contributors retain copyright to elements licensed under a Contributor Agreement.
# Licensed to the User under the AGPL license.

#
# Main library and core entry point of cfengine agent scripts.
#

# helpful cfengine cheatsheet
#
# Natural order of promises inside a bundle
#  vars
#  classes
#  outputs
#  interfaces
#  files
#  packages
#  environments
#  methods
#  processes
#  services
#  commands
#  storage
#  databases
#  reports

#
# common variables in $(sipx.*) space that isn't in a *.cfdat file
#
bundle common sipx {
  vars:
    any::
      "location_id" string => readfile("@SIPX_CFDATA@/defaults/location_id", "100");
      "bind_ip" string => "$(sys.ipv4)";

    SuSE::
      "crontab" string => "/var/spool/cron/tabs/root";

    !SuSE::
      "crontab" string => "/var/spool/cron/root";
      

  classes:
    any::
      # source based installs do not fully integrate. For example, they typically 
      # don't run chkconfig, they don't install crontabs, they don't create unix users.
      #
      # comparing where the service directory is seems like a solid test if src based install
      "src" expression => strcmp("@SIPX_SERVICEDIR@", "/etc/init.d");
}

#
# imports all the variables into $(sipx.*) from *.cfdat files
# 
bundle agent sipx_module {
  commands:
    any::
      "@SIPX_CFMODULES@/sipx"
        args => "$(sipx.location_id)",
        module => "true",
	ifvarclass => canonify(fileexists("@SIPX_CFMODULES@/sipx"));
}

# Copy a local file from cfdata area to final destination if it's changed
# Often you want to include the location id 
# Example:
#  copy_from => copy_from_cfdata("$(sipx.location_id)/myfile"),
#
# 
body copy_from copy_from_cfdata(filename) {
  source => "$(sipx.SIPX_CFDATA)/$(filename)";
  compare => "digest";
}

#
# Registers or deregisters a service into start with system on startup
#
bundle agent rh_chkconfig_status(s){
  classes:
    "${s}_enabled" expression => returnszero("/sbin/chkconfig ${s}", "noshell");

  reports:
    all::
      "${g.pf} Service ${s} is enabled",
        ifvarclass => "${s}_enabled";

      "${g.pk} Service ${s} is not enabled",
        ifvarclass => "!${s}_enabled";
}

#
# Replace the entire contents of a file with a given set of contents
#
# Example:
#  edit_line => replace_contents("file contents here").
#
bundle edit_line replace_contents(contents) {
   insert_lines:
     "$(contents)";

   delete_lines:
      ".*";
}

# 
# Edit select properties of a configuration file that is colon delimited
# Example:
#  var:
#    "x[foo]" string => "bar";
#    "x[goo]" string => "gar";
# ...
#  file:
#   "myfile"
#     edit_line => set_variable_colon_values("x");
#
# Results of myfile contents:
#  a=b
#  foo=bar
#  goo=gar
#  c=d
#
bundle edit_line set_variable_colon_values(v) {
vars:
  "index" slist => getindices("$(v)");
  "cindex[$(index)]" string => canonify("$(index)");

field_edits:
  "\s*$(index)\s*:.*"
     edit_field => col(":", "2", "$($(v)[$(index)])", "set"),
        classes => if_ok("$(cindex[$(index)])_in_file"),
        comment => "Match a line starting like key = something";

insert_lines:
  "$(index) : $($(v)[$(index)])",
         comment => "Insert a variable definition",
      ifvarclass => "!$(cindex[$(index)])_in_file";
}


# 
# Used to find a running service by looking in process table for command name.
# NOTE: When looking for processes started by an init.d script, you'll need
# to specify the path to the binary because that usually what is listed in the
# process table, not the init.d wrapper script.
# 
# Example:
#
#  methods:
#    any::
#      "any" usebundle => find_sipxservice_by_command("/full/path/myservice","myservice_running");
#
#  commands:
#    myservice_running.!supposed_to_be_running::
#      "/full/path/myservice_stop";
#
#    !myservice_running.supposed_to_be_running::
#      "/full/path/myservice_start";
#
bundle agent find_sipxservice_by_command(command,on_find_define) {
  processes:
    "$(command)"
      process_count => on_process_count("$(on_find_define)"),
      process_select => sipxprocess_select("$(command).*");
}

#
# Be careful, cfengine truncates command line after X characters. Best to find
# good identifier early in the command string
#
bundle agent find_sipxservice_by_command_regex(command_regex,on_find_define) {
  processes:
    "$(command_regex)"
      process_count => on_process_count("$(on_find_define)"),
      process_select => sipxprocess_select("$(command_regex)");
}

body process_select sipxprocess_select(command_regex) {
  command => "$(command_regex)";
  process_owner => { "$(sipx.SIPXPBXUSER)" };
  process_result => "command.process_owner";
}

body process_count on_process_count(on_find_define) {
  match_range => "0,0";
  out_of_range_define => { "$(on_find_define)" };
}

#
# Normal process select is by regex in process list, so here's help selecting a 
# process by pid file.
#
# TODO: find a way to call more convieniently
#   - not require pidfile to exists
#   - not to have to call readfile to translate pidfile to pid in caller
#
# Example:
#
#  processes:
#     my_process_should_be_running:
#       "anyname_you_want"
#          process_select => by_pid(readfile("$(my_pidfile)", "100")),
#          restart_class => "start_my_process";
#
body process_select by_pid(pid) {
  pid => irange("$(pid)", "$(pid)");
  process_result => "pid";
}

