#!/usr/bin/ruby

require 'optparse'

$domain_dat = "@SIPX_CFDATA@/domain.cfdat"
$root_keydir = "/var/cfengine/ppkeys"
home_dir = `awk -F : '/@SIPXPBXUSER@/ { print $6 }' /etc/passwd`.chomp
$user_keydir = "#{home_dir}/.cfagent/ppkeys"
$primary_dat = "@SIPX_CFDATA@/defaults/primary.cfdat"
$secondary_dat = "@SIPX_CFDATA@/defaults/secondary.cfdat"
$location_dat = "@SIPX_CFDATA@/defaults/location_id"
$log = "@SIPX_LOGDIR@/sipxecs-setup.log"
$verbose = false
$advanced = false
$cli_options = {}
$exit_status = 0

def run_command(cmd)
  puts cmd if $verbose
  ok = system("#{cmd} >> #{$log} 2>&1")
  if (!ok) 
    puts  "Failure to run command #{cmd}. See #{$log} for details. After you"
    puts  "have addressed the issue, you may rerun this script."
    puts
    if $verbose
      system "cat #{$log}"
    end
    exit 1
  end
end

def set_root_keys
  #harmless if re-run  
  run_command "/usr/sbin/cf-key"
end

def set_nonroot_keys
  #harmless if re-run
  run_command "su - @SIPXPBXUSER@ sh -c '/usr/sbin/cf-key'"
end

def set_secondary
  return true if File.exists?($secondary_dat)
  puts "Configuring as an additional server..."

  master = prompt_required("Enter ip address or fully qualified host name of the primary server : ")

  location_id = prompt_required("Enter numeric id this additional server : ")
  File.open($location_dat,'w') {|f|
    f.puts location_id
  }
  location_dir = "@SIPX_CFDATA@/#{location_id}"
  Dir.mkdir(location_dir) unless File.directory?(location_dir)  
  
  master_cfdata = prompt("Enter MASTER_SIPX_CFDATA [ press enter for @SIPX_CFDATA@ ] : ", "/opt/sipx-main/var/sipxdata/cfdata")
  master_confdir = prompt("Enter MASTER_SIPX_CONFDIR [ press enter for @SIPX_CONFDIR@ ] : ", "/opt/sipx-main/etc/sipxpbx")
  File.open($secondary_dat,'w') {|f|
    f.puts "+sipxsupervisor"
    f.puts "=master=#{master}"
    f.puts "=MASTER_SIPX_CFDATA=#{master_cfdata}"
    f.puts "=MASTER_SIPX_CONFDIR=#{master_confdir}"
  }

  return true
end

def prompt_primary
  while true
    v = prompt_required("Is this the primary server or an additional server?  Enter 'p' for primary or 'a' for additional : ")
    return true if v == 'p'
    return false if v == 'a'
    puts "Invalid response."
  end
end

# Return true or false IF machine is primary, not is anything was done or not
def set_primary
  return false if File.exists?($secondary_dat)
  return true if File.exists?($primary_dat)
  return false unless prompt_primary
  puts "Configuring as the primary server..."
  File.open($location_dat, 'w') {|f|
    f.puts('1')
  }
  puts "Created #{$location_dat}" if $verbose
  File.open($primary_dat, 'w') {|f|
    f.puts <<EOF
+primary
+sipxsupervisor
+postgres
+mongod
EOF
  }
  puts "Created #{$primary_dat}" if $verbose
  return true
end

def prompt_confirm(msg)
  while (true)
    print msg
    value = readline.chomp.downcase
    return false if value == 'n'
    return true if value == 'y'
    puts "Invalid response. Please use 'y' or 'n'."
  end
end

def prompt_required(msg)
  print msg
  while (true)
    value = readline.chomp
    return value unless value.empty?
    puts "Invalid response, you must specify a value."
  end
  return value
end

def prompt(msg, default)
  print msg
  value = readline.chomp
  return value.empty? ? default : value
end

# PRIMARY ONLY
def set_domain
  return if File.exists?($domain_dat)
  current_fqdn = `hostname -f`.chomp
  fqdn = prompt("Enter fully qualified domain name [ press enter for #{current_fqdn} ] : ", current_fqdn)
  domain = prompt("Enter SIP domain name [ press enter for #{fqdn} ] : ", fqdn)
  realm = prompt("Enter SIP realm [ press enter for #{domain} ] : ", domain)
  shared_secret = `head -c 18 /dev/urandom | base64`.chomp
  File.open($domain_dat, 'w') { |f|
    f.puts <<EOF
=domain=#{domain}
=realm=#{realm}
=secret=#{shared_secret}
=lang=en
EOF
  }
  puts "Created #{$domain_dat}" if $verbose
  `chown @SIPXPBXUSER@:@SIPXPBXGROUP@ #{$domain_dat}`
end

def rm_files(d)
  puts "clearing files in directory #{d}" if $verbose
  Dir.foreach(d) { |f|
    fname = "#{d}/#{f}"
    rm_file(fname) if File.file?(fname)
  }
end

def rm_file(f)
  puts "Checking if #{f} exists" if $verbose
  return unless File.exists?(f)
  puts "Removing #{f}" if $verbose
  File.unlink(f)
end

def reset
  rm_file($domain_dat)
  rm_file($primary_dat)
  rm_file($secondary_dat)
  rm_file($location_dat)
end

def reset_all
  reset
  rm_files($root_keydir)
  rm_files($user_keydir)
end

args = OptionParser.new { |opts|
  opts.banner = "Usage : sipxecs-setup [options]"

  opts.separator ""
  opts.separator "Options:"

  opts.on("--verbose", "Send extra details to console.") {
    $verbose = true
  }

  opts.on("--reset", "Force reset of normal settings.") {
    reset
  }

  opts.on("--reset-all", "Force reset of all possible settings including ssl keys.") {
    reset_all
  }

  opts.on("--advanced", "Ask advanced questions.") {
    $advanced = true
  }

  opts.on_tail("--help", "Print options") {
    puts opts
    exit
  }

}
args.parse!

raise 'Must run as root' unless Process.uid == 0
rm_file($log)
set_root_keys()
set_nonroot_keys()
if set_primary()
  set_domain()
else
  set_secondary
end

print "Configuring system, this may take a few minutes..."
run_command("@SIPX_BINDIR@/sipxagent #{'-v' if $verbose}")
puts "done."
