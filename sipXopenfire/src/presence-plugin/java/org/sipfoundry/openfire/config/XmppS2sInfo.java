/*
 * Copyright (C) 2010 Avaya, certain elements licensed under a Contributor Agreement.
 * Contributors retain copyright to elements licensed under a Contributor Agreement.
 * Licensed to the User under the LGPL license.
 */
package org.sipfoundry.openfire.config;

import java.util.Collection;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;

import org.apache.log4j.Logger;
import org.jivesoftware.openfire.SessionManager;
import org.jivesoftware.openfire.XMPPServer;
import org.jivesoftware.openfire.server.RemoteServerConfiguration;
import org.jivesoftware.openfire.server.RemoteServerManager;
import org.jivesoftware.openfire.server.RemoteServerManager.PermissionPolicy;
import org.jivesoftware.openfire.spi.ConnectionManagerImpl;

public class XmppS2sInfo {
	private boolean s2sServerActive;
	private int s2sRemotePort;
	private boolean s2sDisconnectOnIdle;
	private boolean s2sAnyCanConnect;
	private int s2sSessionIdleTimeInMinutes;

	private Map<String, XmppS2sPolicy> xmppS2sAllowedPolicy = new HashMap<String, XmppS2sPolicy>();
	private Map<String, XmppS2sPolicy> xmppS2sDisallowedPolicy = new HashMap<String, XmppS2sPolicy>();

	private static Logger log = Logger.getLogger(XmppS2sInfo.class);

	public XmppS2sInfo() {
	}

	public boolean getS2sServerActive() {
		return this.s2sServerActive;
	}

	public void setS2sServerActive(String s2sServerActive) {
		if (s2sServerActive.equals("1") || s2sServerActive.equals("true")) {
			this.s2sServerActive = true;
		} else {
			this.s2sServerActive = false;
		}
	}

	public int getS2sRemotePort() {
		return this.s2sRemotePort;
	}

	public void setS2sRemotePort(int s2sRemotePort) {
		this.s2sRemotePort = s2sRemotePort;
	}

	public boolean getS2sDisconnectOnIdle() {
		return this.s2sDisconnectOnIdle;
	}

	public void setS2sDisconnectOnIdle(String s2sDisconnectOnIdle) {
		if (s2sDisconnectOnIdle.equals("1") || s2sDisconnectOnIdle.equals("true")) {
			this.s2sDisconnectOnIdle = true;
		} else {
			this.s2sDisconnectOnIdle = false;
		}
	}

	public boolean getS2sAnyCanConnect() {
		return this.s2sAnyCanConnect;
	}

	public void setS2sAnyCanConnect(String s2sAnyCanConnect) {
		if (s2sAnyCanConnect.equals("1") || s2sAnyCanConnect.equals("true")) {
			this.s2sAnyCanConnect = true;
		} else {
			this.s2sAnyCanConnect = false;
		}
	}

	public int getS2sSessionIdleTimeInMinutes() {
		return this.s2sSessionIdleTimeInMinutes;
	}

	public void setS2sSessionIdleTimeInMinutes(int s2sSessionIdleTimeInMinutes) {
		this.s2sSessionIdleTimeInMinutes = s2sSessionIdleTimeInMinutes;
	}

	public void addS2sAllowedPolicy(XmppS2sPolicy xmppS2sPolicy) throws Exception {
		// Add this instance to our collection for later use
		this.xmppS2sAllowedPolicy.put(xmppS2sPolicy.getXmppDomainName(), xmppS2sPolicy);
	}

	public void addS2sDisallowedPolicy(XmppS2sPolicy xmppS2sPolicy) throws Exception {
		// Add this instance to our collection for later use
		this.xmppS2sDisallowedPolicy.put(xmppS2sPolicy.getXmppDomainName(), xmppS2sPolicy);
	}

	public XmppS2sPolicy getXmppS2sAllowedPolicy(String xmppDomainName) {
		return this.xmppS2sAllowedPolicy.get(xmppDomainName);
	}

	public Map<String, XmppS2sPolicy> getXmppS2sAllowedPolicies() {
		return this.xmppS2sAllowedPolicy;
	}

	public XmppS2sPolicy getXmppS2sDisallowedPolicy(String xmppDomainName) {
		return this.xmppS2sDisallowedPolicy.get(xmppDomainName);
	}

	public Map<String, XmppS2sPolicy> getXmppS2sDisallowedPolicies() {
		return this.xmppS2sDisallowedPolicy;
	}

	public void updateS2sSettings() throws Exception {

		// Get the object instance that stores the server to server
		// generated by the sipXconfig side.
		log.debug("updateS2sSettings:" + this.toString());

		// Enable or disable the S2S socket listener and socket port number.
		// The Openfire APIs takes care of the internal restart details.
		ConnectionManagerImpl connManager = (ConnectionManagerImpl) XMPPServer.getInstance()
				.getConnectionManager();
		connManager.enableServerListener(getS2sServerActive());
		connManager.setServerListenerPort(getS2sRemotePort());

		// Set the idle timer duration by converting minutes to milliseconds.
		// No timer expiry is configured using -1.
		XMPPServer server = XMPPServer.getInstance();
		SessionManager sessionManager = server.getSessionManager();
		if (getS2sDisconnectOnIdle()) {
			sessionManager.setServerSessionIdleTime(getS2sSessionIdleTimeInMinutes() * 1000 * 60);
		} else {
			sessionManager.setServerSessionIdleTime(-1);
		}

		// Set the permission policy mode: anyone can connect except or
		// whitelist.
		if (getS2sAnyCanConnect()) {
			RemoteServerManager.setPermissionPolicy(PermissionPolicy.blacklist);
		} else {
			RemoteServerManager.setPermissionPolicy(PermissionPolicy.whitelist);
		}

		updateS2sAllowedPolicies();
		updateS2sDisallowedPolicies();
	}

	public void updateS2sAllowedPolicies() throws Exception {
		// Deal with the allowed remote servers policies.
		// We need two pieces of information:
		// 1) Collection of allowed servers provided by the sipXconfig side
		// 2) The existing list of allowed servers from the existing Openfire
		// database.
		Map<String, XmppS2sPolicy> allowedSipXconfig = getXmppS2sAllowedPolicies();
		Collection<RemoteServerConfiguration> allowedOpenfire = RemoteServerManager
				.getAllowedServers();

		// Use this set to keep track of all keys in the provisioning.
		// Start with the complete set and remove the keys we don't need to add.
		// We figure out if they already exist by comparing against the Openfire
		// database.
		Set<String> policiesToAdd = allowedSipXconfig.keySet();

		log.debug("updateS2sAllowedPolicies:" + " sipXconfig entries = " + allowedSipXconfig.size()
				+ " Openfire entries = " + allowedOpenfire.size());

		// Each existing Openfire allowed policy match its existence on the
		// sipXconfig side to determine the action.
		for (RemoteServerConfiguration openfirePolicy : allowedOpenfire) {
			String key = openfirePolicy.getDomain();
			XmppS2sPolicy allowedPolicy = allowedSipXconfig.get(key);

			if (allowedPolicy == null) {
				// The Openfire allowed policy does not exist for this domain.
				// Delete it in the Openfire database.
				RemoteServerManager.deleteConfiguration(openfirePolicy.getDomain());

				log.debug("delete domain = " + openfirePolicy.getDomain());
			} else {
				// The Openfire allowed domain name exists in both places.
				// Check if the Openfire policy needs to be updated for this
				// domain name.
				if (allowedPolicy.getXmppServerPort() != openfirePolicy.getRemotePort()) {
					// A policy update is required. First delete the entry
					// and let the add action take place after this loop is
					// done.
					RemoteServerManager.deleteConfiguration(openfirePolicy.getDomain());

					log.debug("update(delete+add) domain = " + openfirePolicy.getDomain()
							+ " old port = " + openfirePolicy.getRemotePort());
				} else {
					// The entry exists and is identical. No changes required.
					// Delete the key from the set of entries to add.
					policiesToAdd.remove(key);
				}
			}
		}

		// Iterate over all entries left in the set and add them to the
		// Openfire DB.
		for (String key : policiesToAdd) {
			XmppS2sPolicy entry = allowedSipXconfig.get(key);
			RemoteServerConfiguration configuration = new RemoteServerConfiguration(entry
					.getXmppDomainName());
			configuration.setRemotePort(entry.getXmppServerPort());
			configuration.setPermission(RemoteServerConfiguration.Permission.allowed);
			RemoteServerManager.allowAccess(configuration);

			log.debug("add domain = " + entry.getXmppDomainName() + " port = "
					+ entry.getXmppServerPort());
		}
	}

	public void updateS2sDisallowedPolicies() throws Exception {
		// Deal with the disallowed remote servers policies.
		// We need two pieces of information:
		// 1) Collection of disallowed servers provided by the sipXconfig side
		// 2) The existing list of disallowed servers from the existing Openfire
		// database.
		Map<String, XmppS2sPolicy> disallowedSipXconfig = getXmppS2sDisallowedPolicies();
		Collection<RemoteServerConfiguration> disallowedOpenfire = RemoteServerManager
				.getBlockedServers();

		// Use this set to keep track of all keys in the provisioning.
		// Start with the complete set and remove the keys we don't need to add.
		// We figure out if they already exist by comparing against the Openfire
		// database.
		Set<String> policiesToAdd = disallowedSipXconfig.keySet();

		log.debug("updateS2sDisallowedPolicies:" + " sipXconfig entries = "
				+ disallowedSipXconfig.size() + " Openfire entries = " + disallowedOpenfire.size());

		// Each existing Openfire disallowed policy match its existence on the
		// sipXconfig side to determine the action.
		for (RemoteServerConfiguration openfirePolicy : disallowedOpenfire) {
			String key = openfirePolicy.getDomain();
			XmppS2sPolicy disallowedPolicy = disallowedSipXconfig.get(key);

			if (disallowedPolicy == null) {
				// The Openfire disallowed policy does not exist for this
				// domain. Delete it in the Openfire database.
				RemoteServerManager.deleteConfiguration(openfirePolicy.getDomain());

				log.debug("delete domain = " + openfirePolicy.getDomain());
			} else {
				// The entry exists and is identical. No changes required.
				// Delete the key from the set of entries to add.
				policiesToAdd.remove(key);
			}
		}

		// Iterate over all entries left in the set and add them to the
		// Openfire DB.
		for (String key : policiesToAdd) {
			RemoteServerManager.blockAccess(key);

			log.debug("add domain = " + key);
		}
	}

	public String toString() {

		return new StringBuilder(" active=").append(this.getS2sServerActive()).append(" remPort=")
				.append(this.getS2sRemotePort()).append(" idleDisc=").append(
						this.getS2sDisconnectOnIdle()).append(" anyConn=").append(
						this.getS2sAnyCanConnect()).append(" idleTime=").append(
						this.getS2sSessionIdleTimeInMinutes()).toString();
	}
}
